This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: varia, .specstory, AGENT.md, CLAUDE.md, PLAN.md, SPEC.md, llms.txt, .cursorrules
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.cursor/
  rules/
    attractor-model.mdc
    color-space-models.mdc
    color-transformation-algorithms.mdc
    data-flow-processing.mdc
.giga/
  specifications.json
.github/
  workflows/
    push.yml
    release.yml
src/
  imgcolorshine/
    __init__.py
    __main__.py
    cli.py
    color_engine.py
    falloff.py
    gamut.py
    image_io.py
    imgcolorshine.py
    transforms.py
    utils.py
tests/
  test_package.py
.cursorindexingignore
.gitignore
.pre-commit-config.yaml
CHANGELOG.md
cleanup.sh
LICENSE
package.toml
pyproject.toml
pyrightconfig.json
README.md
TODO.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".cursor/rules/attractor-model.mdc">
---
description: Analyzing attractor-based color transformation models in OKLCH color space, ideal for physics-inspired image color processing systems
globs: **/color_engine.py,**/falloff.py,**/transforms.py,**/attractor*.{py,cpp,h}
alwaysApply: false
---


# attractor-model

## Core Color Attraction Model
The attractor model implements a physics-inspired color transformation system operating in OKLCH color space:

1. Attractor Definition (Score: 95)
- Each attractor specified by target color, tolerance radius, and strength
- Target colors defined in any CSS format, converted to OKLCH coordinates
- Tolerance controls maximum influence distance (0-100)
- Strength determines transformation intensity (0-100)

2. Distance-Based Influence (Score: 90)
- OKLCH perceptual distance calculations between pixels and attractors
- Raised cosine falloff curve for smooth influence transitions
- Independent channel control (lightness, chroma, hue)
- Normalized distance calculations in perceptually uniform space

3. Multi-Attractor Blending (Score: 85)
- Weighted influence blending from multiple attractors
- Normalized weights based on distance and strength
- Channel-specific transformation enabling/disabling
- Cumulative effect calculation with falloff curves

Relevant Files:
- src/imgcolorshine/color_engine.py
- src/imgcolorshine/falloff.py
- src/imgcolorshine/transforms.py

## Key Components

### Attractor Parameters
- Color: Target OKLCH coordinates
- Tolerance: Influence radius (0-100)
- Strength: Pull intensity (0-100)

### Distance Calculation
- Perceptual distance in OKLCH space
- Channel-specific delta calculations
- Normalized distance mapping

### Influence Blending
- Weighted average of attractor influences
- Smooth falloff transitions
- Channel-selective transformations

### Gamut Protection
- CSS Color Module 4 compliant mapping
- Preserves perceptual relationships
- Maintains channel independence

$END$

 If you're using this file in context, clearly say in italics in one small line that "Context added by Giga attractor-model".
</file>

<file path=".cursor/rules/color-space-models.mdc">
---
description: Technical specification for OKLCH, Oklab, and RGB color space models and their transformations in image processing
globs: src/imgcolorshine/color_engine.py,src/imgcolorshine/transforms.py,src/imgcolorshine/gamut.py
alwaysApply: false
---


# color-space-models

## Core Color Space Models

### OKLCH Color Space (Importance: 95)
- Perceptually uniform color space using Lightness, Chroma, and Hue coordinates
- Primary working space for all color transformations
- Enables natural-looking color adjustments due to perceptual uniformity
- Implemented in `color_engine.py` with bidirectional conversions to/from Oklab

### Oklab Color Space (Importance: 90)
- Linear transformation of OKLCH used for accurate distance calculations
- Provides perceptually uniform color differences
- Used for calculating attraction influence between colors
- Core transformations in `transforms.py` handle Oklab-based color operations

### RGB Color Space (Importance: 85)
- Input/output color space for image processing
- Gamut mapping ensures colors remain within displayable sRGB range
- Implemented in `gamut.py` with CSS Color Module 4 compliant mapping

## Color Space Transformations

### Bidirectional Conversions (Importance: 92)
- RGB ↔ Oklab: Linear transformation preserving perceptual uniformity
- Oklab ↔ OKLCH: Polar coordinate conversion for intuitive color manipulation
- Located in `color_engine.py`

### Gamut Mapping (Importance: 88)
- Maps out-of-gamut colors back to displayable sRGB range
- Preserves lightness and hue while reducing chroma
- Implements CSS Color Module 4 specification
- Core functionality in `gamut.py`

### Multi-Space Operations (Importance: 86)
- Color attraction calculations performed in Oklab space
- Visual transformations applied in OKLCH space
- Final output converted to RGB space
- Implemented across `transforms.py` and `color_engine.py`

$END$

 If you're using this file in context, clearly say in italics in one small line that "Context added by Giga color-space-models".
</file>

<file path=".cursor/rules/color-transformation-algorithms.mdc">
---
description: Analysis of color transformation algorithms, focusing on perceptually uniform color space operations and attractor-based color transformations
globs: src/imgcolorshine/color_engine.py,src/imgcolorshine/transforms.py,src/imgcolorshine/falloff.py,src/imgcolorshine/gamut.py
alwaysApply: false
---


# color-transformation-algorithms

## Core Algorithm Components

### Color Attraction Model (Importance: 95)
- Gravitational-inspired color transformation in OKLCH space
- Each attractor defined by target color, tolerance radius, and strength
- Distance-based influence calculation in perceptually uniform space
- File: `src/imgcolorshine/color_engine.py`

### Falloff Functions (Importance: 85)
- Raised cosine curve for smooth color transitions
- Controls attraction strength decay with distance
- Multiple falloff options (cosine, linear, quadratic, gaussian)
- File: `src/imgcolorshine/falloff.py`

### Gamut Mapping (Importance: 90)
- CSS Color Module 4 compliant mapping
- Preserves lightness and hue while reducing chroma
- Ensures displayable colors within sRGB gamut
- File: `src/imgcolorshine/gamut.py`

### Multi-Attractor Blending (Importance: 92)
- Normalized weighted averaging of multiple color influences
- Independent channel control (luminance, saturation, hue)
- Perceptually uniform blending in OKLCH space
- File: `src/imgcolorshine/transforms.py`

## Key Transformations

### OKLCH Color Space Operations (Importance: 88)
- Conversion between RGB, Oklab, and OKLCH spaces
- Perceptually uniform color distance calculations
- Channel-specific transformations
- File: `src/imgcolorshine/color_engine.py`

### Attraction Parameters (Importance: 85)
- Tolerance (0-100): Controls radius of influence
- Strength (0-100): Defines transformation intensity
- Color target: Supports all CSS color formats
- File: `src/imgcolorshine/transforms.py`

$END$

 If you're using this file in context, clearly say in italics in one small line that "Context added by Giga color-transformation-algorithms".
</file>

<file path=".cursor/rules/data-flow-processing.mdc">
---
description: Handles efficient image data processing using tiled memory management and pipeline orchestration
globs: src/imgcolorshine/transforms.py,src/imgcolorshine/utils.py,src/imgcolorshine/image_io.py
alwaysApply: false
---


# data-flow-processing

## Core Data Pipeline Components

### Tiled Image Processing (Importance: 95)
- Located in `src/imgcolorshine/transforms.py`
- Processes large images in memory-efficient tiles 
- Each tile undergoes color space conversion -> transformation -> gamut mapping
- Adjacent tiles are processed with overlap to prevent edge artifacts
- Automatic tile size calculation based on available system memory

### Memory Management System (Importance: 90)
- Located in `src/imgcolorshine/utils.py`
- Implements dynamic memory allocation for image tiles
- Estimates optimal tile dimensions based on:
  - Input image dimensions
  - Color channel count
  - Available system memory
  - Processing overhead requirements

### Data Flow Orchestration (Importance: 85)
Located in `src/imgcolorshine/transforms.py`:
- Controls pipeline stages:
  1. Image loading and validation
  2. Color space conversion (RGB -> OKLCH)
  3. Per-tile attractor application
  4. Gamut mapping
  5. Color space reversion (OKLCH -> RGB)
  6. Result composition

### Image I/O Stream Management (Importance: 80)
Located in `src/imgcolorshine/image_io.py`:
- Handles streaming of image data between disk and memory
- Implements progressive loading for large images
- Manages intermediate buffer allocation
- Controls output stream writing with proper synchronization

### Pipeline-Specific Data Structures
Located in `src/imgcolorshine/transforms.py`:
- TileDescriptor: Manages tile metadata and processing state
- TransformBuffer: Handles intermediate color transformation results
- ProcessingContext: Maintains pipeline state and configuration

### Key Data Flows

1. Input Stream:
```
Disk -> Image Loader -> Tile Generator -> Processing Queue
```

2. Processing Stream:
```
Tile -> Color Transform -> Attractor Application -> Gamut Mapping -> Result Buffer
```

3. Output Stream:
```
Result Buffer -> Tile Composer -> Image Writer -> Disk
```

$END$

 If you're using this file in context, clearly say in italics in one small line that "Context added by Giga data-flow-processing".
</file>

<file path=".giga/specifications.json">
[
  {
    "fileName": "main-overview.mdc",
    "description": "Complete system overview covering the image color transformation architecture, key components, and their interactions within the OKLCH color space system"
  },
  {
    "fileName": "color-transformation-algorithms.mdc",
    "description": "Detailed documentation of the core color transformation algorithms, including the attractor model, falloff functions, and gamut mapping implementations"
  },
  {
    "fileName": "color-space-models.mdc",
    "description": "Comprehensive documentation of the color space models (RGB, OKLCH, Oklab), their relationships, and conversion algorithms used throughout the system"
  },
  {
    "fileName": "data-flow-processing.mdc",
    "description": "Documentation of the image processing pipeline, memory management strategies, and data flow between components including tiled processing for large images"
  },
  {
    "fileName": "attractor-model.mdc",
    "description": "Detailed specification of the color attractor model, including distance calculations, blending mechanisms, and channel-specific transformations"
  }
]
</file>

<file path=".github/workflows/push.yml">
name: Build & Test

on:
  push:
    branches: [main]
    tags-ignore: ["v*"]
  pull_request:
    branches: [main]
  workflow_dispatch:

permissions:
  contents: write
  id-token: write

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  quality:
    name: Code Quality
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Run Ruff lint
        uses: astral-sh/ruff-action@v3
        with:
          version: "latest"
          args: "check --output-format=github"

      - name: Run Ruff Format
        uses: astral-sh/ruff-action@v3
        with:
          version: "latest"
          args: "format --check --respect-gitignore"

  test:
    name: Run Tests
    needs: quality
    strategy:
      matrix:
        python-version: ["3.10", "3.11", "3.12"]
        os: [ubuntu-latest]
      fail-fast: true
    runs-on: ${{ matrix.os }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}

      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          python-version: ${{ matrix.python-version }}
          enable-cache: true
          cache-suffix: ${{ matrix.os }}-${{ matrix.python-version }}

      - name: Install test dependencies
        run: |
          uv pip install --system --upgrade pip
          uv pip install --system ".[test]"

      - name: Run tests with Pytest
        run: uv run pytest -n auto --maxfail=1 --disable-warnings --cov-report=xml --cov-config=pyproject.toml --cov=src/imgcolorshine --cov=tests tests/

      - name: Upload coverage report
        uses: actions/upload-artifact@v4
        with:
          name: coverage-${{ matrix.python-version }}-${{ matrix.os }}
          path: coverage.xml

  build:
    name: Build Distribution
    needs: test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          python-version: "3.12"
          enable-cache: true

      - name: Install build tools
        run: uv pip install build hatchling hatch-vcs

      - name: Build distributions
        run: uv run python -m build --outdir dist

      - name: Upload distribution artifacts
        uses: actions/upload-artifact@v4
        with:
          name: dist-files
          path: dist/
          retention-days: 5
</file>

<file path=".github/workflows/release.yml">
name: Release

on:
  push:
    tags: ["v*"]

permissions:
  contents: write
  id-token: write

jobs:
  release:
    name: Release to PyPI
    runs-on: ubuntu-latest
    environment:
      name: pypi
      url: https://pypi.org/p/imgcolorshine
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          python-version: "3.12"
          enable-cache: true

      - name: Install build tools
        run: uv pip install build hatchling hatch-vcs

      - name: Build distributions
        run: uv run python -m build --outdir dist

      - name: Verify distribution files
        run: |
          ls -la dist/
          test -n "$(find dist -name '*.whl')" || (echo "Wheel file missing" && exit 1)
          test -n "$(find dist -name '*.tar.gz')" || (echo "Source distribution missing" && exit 1)

      - name: Publish to PyPI
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          password: ${{ secrets.PYPI_TOKEN }}

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          files: dist/*
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
</file>

<file path="src/imgcolorshine/__init__.py">
#!/usr/bin/env -S uv run -s
# /// script
# dependencies = []
# ///
# this_file: src/imgcolorshine/__init__.py

"""
imgcolorshine - Transform image colors using OKLCH color attractors.

A physics-inspired tool that operates in perceptually uniform color space,
allowing intuitive color transformations based on attraction principles.
"""

from imgcolorshine.color_engine import Attractor, OKLCHEngine
from imgcolorshine.falloff import FalloffType, get_falloff_function
from imgcolorshine.gamut import GamutMapper
from imgcolorshine.image_io import ImageProcessor
from imgcolorshine.transforms import ColorTransformer
from imgcolorshine.utils import batch_process_images, validate_image

__version__ = "0.1.0"
__all__ = [
    "Attractor",
    "ColorTransformer",
    "FalloffType",
    "GamutMapper",
    "ImageProcessor",
    "OKLCHEngine",
    "batch_process_images",
    "get_falloff_function",
    "validate_image",
]
</file>

<file path="src/imgcolorshine/__main__.py">
#!/usr/bin/env -S uv run -s
# /// script
# dependencies = []
# ///
# this_file: src/imgcolorshine/__main__.py

"""
Entry point for imgcolorshine package.

Thin wrapper that calls the Fire CLI.
"""

from imgcolorshine.cli import main

if __name__ == "__main__":
    main()
</file>

<file path="src/imgcolorshine/cli.py">
#!/usr/bin/env -S uv run -s
# /// script
# dependencies = ["fire", "loguru"]
# ///
# this_file: src/imgcolorshine/cli.py

"""
Fire-based CLI interface for imgcolorshine.

Simple CLI class that delegates to the main processing logic.
"""

import fire
from loguru import logger

from imgcolorshine.imgcolorshine import process_image


class ImgColorShineCLI:
    """CLI interface for imgcolorshine color transformations."""

    def shine(
        self,
        input_image: str,
        *attractors: str,
        output_image: str | None = None,
        luminance: bool = True,
        saturation: bool = True,
        hue: bool = True,
        verbose: bool = False,
        tile_size: int = 1024,
    ) -> None:
        """
        Transform image colors using OKLCH color attractors.

        Args:
            input_image: Path to input image
            *attractors: Color attractors in format "color;tolerance;strength"
            output_image: Output path (auto-generated if not provided)
            luminance: Transform lightness channel
            saturation: Transform chroma (saturation) channel
            hue: Transform hue channel
            verbose: Enable verbose logging
            tile_size: Tile size for processing large images

        Examples:
            imgcolorshine shine photo.jpg "red;50;75"
            imgcolorshine shine landscape.png "oklch(80% 0.2 60);40;60" "#ff6b35;30;80" --output_image=sunset.png
            imgcolorshine shine portrait.jpg "green;60;90" --luminance=False --saturation=False

        """
        # Delegate to main processing logic
        process_image(
            input_image=input_image,
            attractors=attractors,
            output_image=output_image,
            luminance=luminance,
            saturation=saturation,
            hue=hue,
            verbose=verbose,
            tile_size=tile_size,
        )


def main():
    """Fire CLI entry point.

    Used in:
    - src/imgcolorshine/__main__.py
    """
    fire.Fire(ImgColorShineCLI)


if __name__ == "__main__":
    main()
</file>

<file path="src/imgcolorshine/color_engine.py">
#!/usr/bin/env -S uv run -s
# /// script
# dependencies = ["coloraide", "numpy", "loguru"]
# ///
# this_file: src/imgcolorshine/color_engine.py

"""
OKLCH color space operations and attractor management.

Handles color parsing, OKLCH/Oklab conversions, delta E calculations,
and gamut mapping. This module is the core of the color transformation
system, providing perceptually uniform color operations.

"""

from dataclasses import dataclass

import numpy as np
from coloraide import Color
from loguru import logger


@dataclass
class Attractor:
    """Represents a color attractor with its parameters.

    Stores color information in both OKLCH and Oklab formats for
    efficient processing. Used by transforms.py for applying color
    attractions to images.

    Used in:
    - old/imgcolorshine/imgcolorshine/__init__.py
    - old/imgcolorshine/imgcolorshine/transforms.py
    - src/imgcolorshine/__init__.py
    - src/imgcolorshine/transforms.py
    """

    color: Color  # In OKLCH space
    tolerance: float  # 0-100
    strength: float  # 0-100
    oklch_values: tuple[float, float, float]  # L, C, H
    oklab_values: tuple[float, float, float]  # L, a, b

    def __post_init__(self):
        """Cache commonly used conversions for performance."""
        self.oklch_values = (
            self.color["lightness"],
            self.color["chroma"],
            self.color["hue"],
        )

        # Convert to Oklab for distance calculations
        oklab_color = self.color.convert("oklab")
        self.oklab_values = (
            oklab_color["lightness"],
            oklab_color["a"],
            oklab_color["b"],
        )


class OKLCHEngine:
    """Handles OKLCH color space operations and conversions.

    Central engine for all color operations, providing OKLCH/Oklab
    conversions, color parsing, and gamut mapping. Used throughout
    the application for perceptually uniform color transformations.

    Used in:
    - old/imgcolorshine/imgcolorshine/__init__.py
    - old/imgcolorshine/imgcolorshine/transforms.py
    - old/imgcolorshine/imgcolorshine_main.py
    - old/imgcolorshine/test_imgcolorshine.py
    - src/imgcolorshine/__init__.py
    - src/imgcolorshine/imgcolorshine.py
    - src/imgcolorshine/transforms.py
    """

    def __init__(self):
        """Initialize the color engine with caching."""
        self.cache: dict[str, Color] = {}
        logger.debug("Initialized OKLCH color engine")

    def parse_color(self, color_str: str) -> Color:
        """
        Parse any CSS color format and return a Color object.

        Supports: hex, rgb(), hsl(), oklch(), named colors, etc.
        Results are cached for performance.

        Used in:
        - old/imgcolorshine/test_imgcolorshine.py
        """
        if color_str in self.cache:
            return self.cache[color_str].clone()

        try:
            color = Color(color_str)
            self.cache[color_str] = color.clone()
            logger.debug(f"Parsed color '{color_str}' → {color}")
            return color
        except Exception as e:
            logger.error(f"Failed to parse color '{color_str}': {e}")
            msg = f"Invalid color specification: {color_str}"
            raise ValueError(msg) from e

    def create_attractor(self, color_str: str, tolerance: float, strength: float) -> Attractor:
        """Create an attractor from color string and parameters.

        Parses the color string and converts to OKLCH space for
        perceptually uniform operations.

        Used in:
        - old/imgcolorshine/imgcolorshine_main.py
        - old/imgcolorshine/test_imgcolorshine.py
        - src/imgcolorshine/imgcolorshine.py
        """
        color = self.parse_color(color_str)
        oklch_color = color.convert("oklch")

        return Attractor(color=oklch_color, tolerance=tolerance, strength=strength)

    def calculate_delta_e(self, color1: np.ndarray, color2: np.ndarray) -> float:
        """
        Calculate perceptual distance in Oklab space.

        Args:
            color1: [L, a, b] values
            color2: [L, a, b] values

        Returns:
            Euclidean distance in Oklab space

        """
        return np.sqrt(np.sum((color1 - color2) ** 2))

    def oklch_to_oklab(self, l: float, c: float, h: float) -> tuple[float, float, float]:
        """Convert OKLCH to Oklab coordinates."""
        h_rad = np.deg2rad(h)
        a = c * np.cos(h_rad)
        b = c * np.sin(h_rad)
        return l, a, b

    def oklab_to_oklch(self, l: float, a: float, b: float) -> tuple[float, float, float]:
        """Convert Oklab to OKLCH coordinates.

        Used by transforms.py for color space conversions.

        Used in:
        - old/imgcolorshine/imgcolorshine/transforms.py
        - src/imgcolorshine/transforms.py
        """
        c = np.sqrt(a**2 + b**2)
        h = np.rad2deg(np.arctan2(b, a))
        if h < 0:
            h += 360
        return l, c, h

    def rgb_to_oklab(self, rgb: np.ndarray) -> np.ndarray:
        """
        Convert sRGB to Oklab.

        Args:
            rgb: Array of shape (..., 3) with values in [0, 1]

        Returns:
            Array of shape (..., 3) with Oklab values

        """
        # First convert to linear RGB
        self.srgb_to_linear(rgb)

        # Convert to Oklab using ColorAide's matrices
        # This is a simplified version - in production, use ColorAide's convert
        color = Color("srgb", list(rgb))
        oklab = color.convert("oklab")
        return np.array([oklab["lightness"], oklab["a"], oklab["b"]])

    def oklab_to_rgb(self, oklab: np.ndarray) -> np.ndarray:
        """
        Convert Oklab to sRGB.

        Args:
            oklab: Array of shape (..., 3) with Oklab values

        Returns:
            Array of shape (..., 3) with sRGB values in [0, 1]

        """
        # Use ColorAide for accurate conversion
        color = Color("oklab", list(oklab))
        srgb = color.convert("srgb")
        return np.array([srgb["red"], srgb["green"], srgb["blue"]])

    def srgb_to_linear(self, srgb: np.ndarray) -> np.ndarray:
        """Apply inverse gamma correction."""
        return np.where(srgb <= 0.04045, srgb / 12.92, np.power((srgb + 0.055) / 1.055, 2.4))

    def linear_to_srgb(self, linear: np.ndarray) -> np.ndarray:
        """Apply gamma correction."""
        return np.where(
            linear <= 0.0031308,
            linear * 12.92,
            1.055 * np.power(linear, 1 / 2.4) - 0.055,
        )

    def gamut_map_oklch(self, l: float, c: float, h: float) -> tuple[float, float, float]:
        """
        CSS Color Module 4 compliant gamut mapping.

        Reduces chroma while preserving lightness and hue until the color
        is within sRGB gamut. Uses binary search for efficiency.

        """
        color = Color("oklch", [l, c, h])

        if color.in_gamut("srgb"):
            return l, c, h

        # Binary search for maximum valid chroma
        c_min, c_max = 0.0, c
        epsilon = 0.0001

        while c_max - c_min > epsilon:
            c_mid = (c_min + c_max) / 2
            test_color = Color("oklch", [l, c_mid, h])

            if test_color.in_gamut("srgb"):
                c_min = c_mid
            else:
                c_max = c_mid

        logger.debug(f"Gamut mapped: C={c:.3f} → {c_min:.3f}")
        return l, c_min, h

    def batch_rgb_to_oklab(self, rgb_image: np.ndarray) -> np.ndarray:
        """
        Convert entire RGB image to Oklab.

        Args:
            rgb_image: Array of shape (H, W, 3) with values in [0, 1]

        Returns:
            Array of shape (H, W, 3) with Oklab values

        Used by transforms.py for batch image processing.

        Used in:
        - old/imgcolorshine/imgcolorshine/transforms.py
        - src/imgcolorshine/transforms.py
        """
        # Flatten for batch processing
        h, w = rgb_image.shape[:2]
        flat_rgb = rgb_image.reshape(-1, 3)

        # Convert each pixel - in production, use vectorized ColorAide
        oklab_list = []
        for rgb in flat_rgb:
            color = Color("srgb", list(rgb))
            oklab = color.convert("oklab")
            oklab_list.append([oklab["lightness"], oklab["a"], oklab["b"]])

        return np.array(oklab_list).reshape(h, w, 3)

    def batch_oklab_to_rgb(self, oklab_image: np.ndarray) -> np.ndarray:
        """
        Convert entire Oklab image to RGB.

        Args:
            oklab_image: Array of shape (H, W, 3) with Oklab values

        Returns:
            Array of shape (H, W, 3) with sRGB values in [0, 1]

        Used by transforms.py for batch image processing.

        Used in:
        - old/imgcolorshine/imgcolorshine/transforms.py
        - src/imgcolorshine/transforms.py
        """
        # Flatten for batch processing
        h, w = oklab_image.shape[:2]
        flat_oklab = oklab_image.reshape(-1, 3)

        # Convert each pixel - in production, use vectorized ColorAide
        rgb_list = []
        for oklab in flat_oklab:
            color = Color("oklab", list(oklab))

            # Gamut map if needed
            if not color.in_gamut("srgb"):
                oklch = color.convert("oklch")
                l, c, h = self.gamut_map_oklch(oklch["lightness"], oklch["chroma"], oklch["hue"])
                color = Color("oklch", [l, c, h])

            srgb = color.convert("srgb")
            rgb_list.append([srgb["red"], srgb["green"], srgb["blue"]])

        return np.array(rgb_list).reshape(h, w, 3)
</file>

<file path="src/imgcolorshine/falloff.py">
#!/usr/bin/env -S uv run -s
# /// script
# dependencies = ["numpy", "numba"]
# ///
# this_file: src/imgcolorshine/falloff.py

"""
Falloff functions for color attraction.

Provides various mathematical curves for controlling how color attraction
strength decreases with distance. The raised cosine is the default and
recommended function for smooth, natural transitions.
"""

from collections.abc import Callable
from enum import Enum

import numba
import numpy as np


class FalloffType(Enum):
    """Available falloff curve types.

    Different mathematical functions for controlling attraction falloff.
    Used for customizing the behavior of color transformations.

    Used in:
    - old/imgcolorshine/test_imgcolorshine.py
    - src/imgcolorshine/__init__.py
    """

    COSINE = "cosine"  # Smooth raised cosine (default)
    LINEAR = "linear"  # Simple linear falloff
    QUADRATIC = "quadratic"  # Quadratic ease-out
    GAUSSIAN = "gaussian"  # Gaussian bell curve
    CUBIC = "cubic"  # Cubic ease-out


@numba.njit
def falloff_cosine(d_norm: float) -> float:
    """
    Raised cosine falloff (smooth and natural).

    This is the default and recommended falloff function,
    providing smooth transitions without harsh edges.

    """
    return 0.5 * (np.cos(d_norm * np.pi) + 1.0)


@numba.njit
def falloff_linear(d_norm: float) -> float:
    """Simple linear falloff."""
    return 1.0 - d_norm


@numba.njit
def falloff_quadratic(d_norm: float) -> float:
    """Quadratic ease-out falloff."""
    return 1.0 - d_norm * d_norm


@numba.njit
def falloff_gaussian(d_norm: float) -> float:
    """
    Gaussian falloff with sigma=0.4.

    Provides a bell curve with most influence near the center.

    """
    sigma = 0.4
    return np.exp(-(d_norm * d_norm) / (2 * sigma * sigma))


@numba.njit
def falloff_cubic(d_norm: float) -> float:
    """Cubic ease-out falloff."""
    inv = 1.0 - d_norm
    return inv * inv * inv


@numba.njit
def calculate_falloff(d_norm: float, falloff_type: int = 0) -> float:
    """
    Calculate falloff value based on normalized distance.

    Args:
        d_norm: Normalized distance (0 to 1)
        falloff_type: Type of falloff curve (0=cosine, 1=linear, etc.)

    Returns:
        Falloff value (0 to 1)

    """
    if falloff_type == 0:  # COSINE
        return falloff_cosine(d_norm)
    if falloff_type == 1:  # LINEAR
        return falloff_linear(d_norm)
    if falloff_type == 2:  # QUADRATIC
        return falloff_quadratic(d_norm)
    if falloff_type == 3:  # GAUSSIAN
        return falloff_gaussian(d_norm)
    if falloff_type == 4:  # CUBIC
        return falloff_cubic(d_norm)
    # Default to cosine
    return falloff_cosine(d_norm)


def get_falloff_function(falloff_type: FalloffType) -> Callable[[float], float]:
    """
    Get the appropriate falloff function.

    Args:
        falloff_type: Type of falloff curve

    Returns:
        Falloff function

    Used in:
    - src/imgcolorshine/__init__.py
    """
    mapping = {
        FalloffType.COSINE: falloff_cosine,
        FalloffType.LINEAR: falloff_linear,
        FalloffType.QUADRATIC: falloff_quadratic,
        FalloffType.GAUSSIAN: falloff_gaussian,
        FalloffType.CUBIC: falloff_cubic,
    }

    return mapping.get(falloff_type, falloff_cosine)


def visualize_falloff(falloff_type: FalloffType, samples: int = 100) -> np.ndarray:
    """
    Generate data for visualizing a falloff curve.

    Args:
        falloff_type: Type of falloff curve
        samples: Number of samples to generate

    Returns:
        Array of shape (samples, 2) with [distance, falloff] pairs

    Used for testing and visualization purposes.

    Used in:
    - old/imgcolorshine/test_imgcolorshine.py
    """
    distances = np.linspace(0, 1, samples)
    falloff_func = get_falloff_function(falloff_type)

    values = np.array([falloff_func(d) for d in distances])

    return np.column_stack([distances, values])


def precompute_falloff_lut(falloff_type: FalloffType = FalloffType.COSINE, resolution: int = 1024) -> np.ndarray:
    """
    Precompute a lookup table for fast falloff calculations.

    Args:
        falloff_type: Type of falloff curve
        resolution: Number of entries in the lookup table

    Returns:
        Lookup table array

    """
    lut = np.zeros(resolution, dtype=np.float32)
    falloff_func = get_falloff_function(falloff_type)

    for i in range(resolution):
        d_norm = i / (resolution - 1)
        lut[i] = falloff_func(d_norm)

    return lut


@numba.njit
def apply_falloff_lut(d_norm: float, lut: np.ndarray) -> float:
    """
    Apply falloff using a precomputed lookup table.

    Args:
        d_norm: Normalized distance (0 to 1)
        lut: Precomputed lookup table

    Returns:
        Interpolated falloff value

    """
    # Get LUT index
    idx_float = d_norm * (len(lut) - 1)
    idx = int(idx_float)

    # Handle edge cases
    if idx >= len(lut) - 1:
        return lut[-1]
    if idx < 0:
        return lut[0]

    # Linear interpolation between LUT entries
    frac = idx_float - idx
    return lut[idx] * (1 - frac) + lut[idx + 1] * frac
</file>

<file path="src/imgcolorshine/gamut.py">
#!/usr/bin/env -S uv run -s
# /// script
# dependencies = ["numpy", "coloraide", "loguru"]
# ///
# this_file: src/imgcolorshine/gamut.py

"""
CSS Color Module 4 compliant gamut mapping.

Implements the standard algorithm for mapping out-of-gamut colors back
to the displayable range while preserving perceptual attributes. Uses
binary search to find the maximum chroma that fits within gamut.

"""

import numpy as np
from coloraide import Color
from loguru import logger


class GamutMapper:
    """Handles gamut mapping for out-of-bounds colors.

    Ensures all colors are displayable in the target color space (sRGB)
    by reducing chroma while preserving lightness and hue. Follows the
    CSS Color Module 4 specification for consistent results.

    Used in:
    - old/imgcolorshine/test_imgcolorshine.py
    - src/imgcolorshine/__init__.py
    """

    def __init__(self, target_space: str = "srgb"):
        """
        Initialize the gamut mapper.

        Args:
            target_space: Target color space for gamut mapping

        """
        self.target_space = target_space
        self.epsilon = 0.0001
        logger.debug(f"Initialized GamutMapper for {target_space}")

    def is_in_gamut(self, color: Color) -> bool:
        """Check if a color is within the target gamut."""
        return color.in_gamut(self.target_space)

    def map_oklch_to_gamut(self, l: float, c: float, h: float) -> tuple[float, float, float]:
        """
        CSS Color Module 4 gamut mapping algorithm.

        Reduces chroma while preserving lightness and hue until
        the color fits within the target gamut.

        Args:
            l: Lightness (0-1)
            c: Chroma (0-0.4+)
            h: Hue (0-360)

        Returns:
            Gamut-mapped OKLCH values

        Used in:
        - old/imgcolorshine/test_imgcolorshine.py
        """
        # Create color object
        color = Color("oklch", [l, c, h])

        # Check if already in gamut
        if self.is_in_gamut(color):
            return l, c, h

        # Binary search for maximum valid chroma
        c_min = 0.0
        c_max = c

        iterations = 0
        max_iterations = 20

        while c_max - c_min > self.epsilon and iterations < max_iterations:
            c_mid = (c_min + c_max) / 2
            test_color = Color("oklch", [l, c_mid, h])

            if self.is_in_gamut(test_color):
                c_min = c_mid
            else:
                c_max = c_mid

            iterations += 1

        # Use the last valid chroma value
        final_c = c_min

        logger.debug(f"Gamut mapped: C={c:.4f} → {final_c:.4f} (iterations: {iterations})")

        return l, final_c, h

    def map_oklab_to_gamut(self, l: float, a: float, b: float) -> tuple[float, float, float]:
        """
        Map Oklab color to gamut by converting to OKLCH first.

        Args:
            l: Lightness
            a: Green-red axis
            b: Blue-yellow axis

        Returns:
            Gamut-mapped Oklab values

        """
        # Convert to OKLCH
        c = np.sqrt(a**2 + b**2)
        h = np.rad2deg(np.arctan2(b, a))
        if h < 0:
            h += 360

        # Map to gamut
        l_mapped, c_mapped, h_mapped = self.map_oklch_to_gamut(l, c, h)

        # Convert back to Oklab
        h_rad = np.deg2rad(h_mapped)
        a_mapped = c_mapped * np.cos(h_rad)
        b_mapped = c_mapped * np.sin(h_rad)

        return l_mapped, a_mapped, b_mapped

    def map_rgb_to_gamut(self, r: float, g: float, b: float) -> tuple[float, float, float]:
        """
        Simple RGB gamut mapping by clamping.

        For more sophisticated mapping, convert to OKLCH first.

        Args:
            r, g, b: RGB values (may be outside [0, 1])

        Returns:
            Clamped RGB values in [0, 1]

        """
        return (np.clip(r, 0, 1), np.clip(g, 0, 1), np.clip(b, 0, 1))

    def batch_map_oklch(self, colors: np.ndarray) -> np.ndarray:
        """
        Map multiple OKLCH colors to gamut.

        Args:
            colors: Array of shape (..., 3) with OKLCH values

        Returns:
            Gamut-mapped colors

        """
        shape = colors.shape
        flat_colors = colors.reshape(-1, 3)
        mapped_colors = np.zeros_like(flat_colors)

        for i, (l, c, h) in enumerate(flat_colors):
            mapped_colors[i] = self.map_oklch_to_gamut(l, c, h)

        return mapped_colors.reshape(shape)

    def analyze_gamut_coverage(self, colors: np.ndarray) -> dict:
        """
        Analyze how many colors are out of gamut.

        Args:
            colors: Array of colors in any format

        Returns:
            Dictionary with gamut statistics

        """
        total_colors = len(colors)
        out_of_gamut = 0

        for color_values in colors:
            color = Color("oklch", list(color_values))
            if not self.is_in_gamut(color):
                out_of_gamut += 1

        in_gamut = total_colors - out_of_gamut
        percentage_in = (in_gamut / total_colors) * 100 if total_colors > 0 else 100

        return {
            "total": total_colors,
            "in_gamut": in_gamut,
            "out_of_gamut": out_of_gamut,
            "percentage_in_gamut": percentage_in,
        }


def create_gamut_boundary_lut(hue_steps: int = 360, lightness_steps: int = 100) -> np.ndarray:
    """
    Create a lookup table for maximum chroma at each hue/lightness.

    This can speed up gamut mapping for real-time applications.

    Args:
        hue_steps: Number of hue divisions
        lightness_steps: Number of lightness divisions

    Returns:
        2D array of maximum chroma values

    """
    lut = np.zeros((lightness_steps, hue_steps), dtype=np.float32)
    mapper = GamutMapper()

    for l_idx in range(lightness_steps):
        l = l_idx / (lightness_steps - 1)

        for h_idx in range(hue_steps):
            h = (h_idx / hue_steps) * 360

            # Binary search for max chroma
            c_min, c_max = 0.0, 0.5  # Max reasonable chroma

            while c_max - c_min > 0.001:
                c_mid = (c_min + c_max) / 2
                color = Color("oklch", [l, c_mid, h])

                if mapper.is_in_gamut(color):
                    c_min = c_mid
                else:
                    c_max = c_mid

            lut[l_idx, h_idx] = c_min

    return lut
</file>

<file path="src/imgcolorshine/image_io.py">
#!/usr/bin/env -S uv run -s
# /// script
# dependencies = ["numpy", "loguru", "opencv-python", "pillow"]
# ///
# this_file: src/imgcolorshine/image_io.py

"""
High-performance image I/O with OpenCV and PIL fallback.

Provides efficient image loading and saving with automatic format detection,
memory estimation for large images, and tiling support. OpenCV is preferred
for performance, with PIL as a fallback.

"""

from pathlib import Path

import numpy as np
from loguru import logger

# Try to import OpenCV first (faster), fall back to PIL
try:
    import cv2

    HAS_OPENCV = True
    logger.debug("Using OpenCV for image I/O")
except ImportError:
    HAS_OPENCV = False
    logger.warning("OpenCV not available, falling back to PIL")

from PIL import Image


class ImageProcessor:
    """Handles image loading and saving with optimal performance.

    Provides high-performance image I/O with OpenCV (preferred) or PIL fallback.
    Includes memory estimation and tiling support for large images. Used throughout
    the application for all image file operations.

    Used in:
    - old/imgcolorshine/imgcolorshine/__init__.py
    - old/imgcolorshine/imgcolorshine/transforms.py
    - old/imgcolorshine/imgcolorshine/utils.py
    - old/imgcolorshine/imgcolorshine_main.py
    - old/imgcolorshine/test_imgcolorshine.py
    - src/imgcolorshine/__init__.py
    - src/imgcolorshine/imgcolorshine.py
    - src/imgcolorshine/transforms.py
    - src/imgcolorshine/utils.py
    """

    def __init__(self, tile_size: int = 1024):
        """
        Initialize the image processor.

        Args:
            tile_size: Size of tiles for processing large images

        """
        self.tile_size = tile_size
        self.use_opencv = HAS_OPENCV
        logger.debug(f"ImageProcessor initialized (OpenCV: {self.use_opencv}, tile_size: {tile_size})")

    def load_image(self, path: str | Path) -> np.ndarray:
        """
        Load an image from file.

        Args:
            path: Path to the image file

        Returns:
            Image as numpy array with shape (H, W, 3) and values in [0, 1]

        Used by utils.py and main CLI for loading input images.

        Used in:
        - old/imgcolorshine/imgcolorshine/utils.py
        - old/imgcolorshine/imgcolorshine_main.py
        - src/imgcolorshine/imgcolorshine.py
        - src/imgcolorshine/utils.py
        """
        path = Path(path)

        if not path.exists():
            msg = f"Image not found: {path}"
            raise FileNotFoundError(msg)

        logger.info(f"Loading image: {path}")

        if self.use_opencv:
            return self._load_opencv(path)
        return self._load_pil(path)

    def save_image(self, image: np.ndarray, path: str | Path, quality: int = 95) -> None:
        """
        Save an image to file.

        Args:
            image: Image array with values in [0, 1]
            path: Output path
            quality: JPEG quality (1-100) or PNG compression (0-9)

        Used by utils.py and main CLI for saving output images.

        Used in:
        - old/imgcolorshine/imgcolorshine/utils.py
        - old/imgcolorshine/imgcolorshine_main.py
        - old/imgcolorshine/test_imgcolorshine.py
        - src/imgcolorshine/imgcolorshine.py
        - src/imgcolorshine/utils.py
        """
        path = Path(path)

        # Ensure output directory exists
        path.parent.mkdir(parents=True, exist_ok=True)

        logger.info(f"Saving image: {path}")

        if self.use_opencv:
            self._save_opencv(image, path, quality)
        else:
            self._save_pil(image, path, quality)

    def _load_opencv(self, path: Path) -> np.ndarray:
        """Load image using OpenCV for better performance."""
        # OpenCV loads as BGR, we need RGB
        img = cv2.imread(str(path), cv2.IMREAD_COLOR)

        if img is None:
            msg = f"Failed to load image: {path}"
            raise ValueError(msg)

        # Convert BGR to RGB
        img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)

        # Convert to float [0, 1]
        img = img.astype(np.float32) / 255.0

        h, w = img.shape[:2]
        logger.debug(f"Loaded {w}×{h} image with OpenCV")

        return img

    def _load_pil(self, path: Path) -> np.ndarray:
        """Load image using PIL as fallback."""
        with Image.open(path) as img:
            # Convert to RGB if necessary
            if img.mode != "RGB":
                logger.debug(f"Converting from {img.mode} to RGB")
                img = img.convert("RGB")

            # Convert to numpy array
            arr = np.array(img, dtype=np.float32) / 255.0

            h, w = arr.shape[:2]
            logger.debug(f"Loaded {w}×{h} image with PIL")

            return arr

    def _save_opencv(self, image: np.ndarray, path: Path, quality: int) -> None:
        """Save image using OpenCV for better performance."""
        # Ensure values are in [0, 1]
        image = np.clip(image, 0, 1)

        # Convert to uint8
        img_uint8 = (image * 255).astype(np.uint8)

        # Convert RGB to BGR for OpenCV
        img_bgr = cv2.cvtColor(img_uint8, cv2.COLOR_RGB2BGR)

        # Set compression parameters based on format
        ext = path.suffix.lower()
        if ext in [".jpg", ".jpeg"]:
            params = [cv2.IMWRITE_JPEG_QUALITY, quality]
        elif ext == ".png":
            # PNG compression level (0-9, where 9 is max compression)
            compression = int((100 - quality) / 11)
            params = [cv2.IMWRITE_PNG_COMPRESSION, compression]
        else:
            params = []

        success = cv2.imwrite(str(path), img_bgr, params)

        if not success:
            msg = f"Failed to save image: {path}"
            raise OSError(msg)

        logger.debug(f"Saved image with OpenCV (quality: {quality})")

    def _save_pil(self, image: np.ndarray, path: Path, quality: int) -> None:
        """Save image using PIL as fallback."""
        # Ensure values are in [0, 1]
        image = np.clip(image, 0, 1)

        # Convert to uint8
        img_uint8 = (image * 255).astype(np.uint8)

        # Create PIL Image
        pil_img = Image.fromarray(img_uint8, mode="RGB")

        # Set save parameters based on format
        ext = path.suffix.lower()
        save_kwargs = {}

        if ext in [".jpg", ".jpeg"]:
            save_kwargs["quality"] = quality
            save_kwargs["optimize"] = True
        elif ext == ".png":
            # PNG compression level
            save_kwargs["compress_level"] = int((100 - quality) / 11)

        pil_img.save(path, **save_kwargs)

        logger.debug(f"Saved image with PIL (quality: {quality})")

    def estimate_memory_usage(self, width: int, height: int) -> int:
        """
        Estimate memory usage for processing an image.

        Returns:
            Estimated memory usage in MB

        """
        # Each pixel: 3 channels × 4 bytes (float32) × 2 (input + output)
        pixels = width * height
        bytes_per_pixel = 3 * 4 * 2

        # Add overhead for intermediate calculations (attractors, etc.)
        overhead_factor = 1.5

        total_bytes = pixels * bytes_per_pixel * overhead_factor
        total_mb = total_bytes / (1024 * 1024)

        return int(total_mb)

    def should_use_tiling(self, width: int, height: int, max_memory_mb: int = 2048) -> bool:
        """
        Determine if image should be processed in tiles.

        Args:
            width: Image width
            height: Image height
            max_memory_mb: Maximum memory to use

        Returns:
            True if tiling should be used

        Used by transforms.py to decide on processing strategy.

        Used in:
        - old/imgcolorshine/imgcolorshine/transforms.py
        - src/imgcolorshine/transforms.py
        """
        estimated_mb = self.estimate_memory_usage(width, height)
        should_tile = estimated_mb > max_memory_mb

        if should_tile:
            logger.info(
                f"Large image ({width}×{height}), using tiled processing "
                f"(estimated {estimated_mb}MB > {max_memory_mb}MB limit)"
            )

        return should_tile
</file>

<file path="src/imgcolorshine/transforms.py">
#!/usr/bin/env -S uv run -s
# /// script
# dependencies = ["numpy", "numba", "loguru"]
# ///
# this_file: src/imgcolorshine/transforms.py

"""
High-performance color transformation algorithms using NumPy and Numba.

Implements the core color transformation logic with JIT compilation for
optimal performance. Handles multi-attractor blending and channel-specific
transformations in the OKLCH color space.

"""

from collections.abc import Callable

import numba
import numpy as np
from loguru import logger

from imgcolorshine.color_engine import Attractor, OKLCHEngine
from imgcolorshine.utils import process_large_image


@numba.njit
def calculate_delta_e_fast(pixel_lab: np.ndarray, attractor_lab: np.ndarray) -> float:
    """
    Fast Euclidean distance calculation in Oklab space.

    Args:
        pixel_lab: [L, a, b] values
        attractor_lab: [L, a, b] values

    Returns:
        Perceptual distance

    """
    return np.sqrt(
        (pixel_lab[0] - attractor_lab[0]) ** 2
        + (pixel_lab[1] - attractor_lab[1]) ** 2
        + (pixel_lab[2] - attractor_lab[2]) ** 2
    )


@numba.njit
def calculate_weights(
    pixel_lab: np.ndarray,
    attractors_lab: np.ndarray,
    tolerances: np.ndarray,
    strengths: np.ndarray,
) -> np.ndarray:
    """
    Calculate attraction weights for all attractors.

    Returns:
        Array of weights for each attractor

    """
    num_attractors = len(attractors_lab)
    weights = np.zeros(num_attractors)

    for i in range(num_attractors):
        # Calculate perceptual distance
        delta_e = calculate_delta_e_fast(pixel_lab, attractors_lab[i])

        # Map tolerance (0-100) to max distance
        delta_e_max = 1.0 * (tolerances[i] / 100.0) ** 2

        # Check if within tolerance
        if delta_e <= delta_e_max:
            # Calculate normalized distance
            d_norm = delta_e / delta_e_max

            # Apply falloff function (raised cosine)
            attraction_factor = 0.5 * (np.cos(d_norm * np.pi) + 1.0)

            # Calculate final weight
            weights[i] = (strengths[i] / 100.0) * attraction_factor

    return weights


@numba.njit
def blend_colors(
    pixel_lab: np.ndarray,
    pixel_lch: np.ndarray,
    attractors_lab: np.ndarray,
    attractors_lch: np.ndarray,
    weights: np.ndarray,
    flags: np.ndarray,
) -> np.ndarray:
    """
    Blend pixel color with attractors based on weights and channel flags.

    Args:
        pixel_lab: Original pixel in Oklab [L, a, b]
        pixel_lch: Original pixel in OKLCH [L, C, H]
        attractors_lab: Attractor colors in Oklab
        attractors_lch: Attractor colors in OKLCH
        weights: Weight for each attractor
        flags: Boolean array [luminance, saturation, hue]

    Returns:
        Blended color in Oklab space

    """
    total_weight = np.sum(weights)

    if total_weight == 0:
        return pixel_lab

    # Determine source weight
    if total_weight > 1.0:
        # Normalize weights
        weights = weights / total_weight
        src_weight = 0.0
    else:
        src_weight = 1.0 - total_weight

    # Start with original values
    final_l = pixel_lch[0]
    final_c = pixel_lch[1]
    final_h = pixel_lch[2]

    # Blend each enabled channel
    if flags[0]:  # Luminance
        final_l = src_weight * pixel_lch[0]
        for i in range(len(weights)):
            if weights[i] > 0:
                final_l += weights[i] * attractors_lch[i][0]

    if flags[1]:  # Saturation (Chroma)
        final_c = src_weight * pixel_lch[1]
        for i in range(len(weights)):
            if weights[i] > 0:
                final_c += weights[i] * attractors_lch[i][1]

    if flags[2]:  # Hue
        # Use circular mean for hue
        sin_sum = src_weight * np.sin(np.deg2rad(pixel_lch[2]))
        cos_sum = src_weight * np.cos(np.deg2rad(pixel_lch[2]))

        for i in range(len(weights)):
            if weights[i] > 0:
                h_rad = np.deg2rad(attractors_lch[i][2])
                sin_sum += weights[i] * np.sin(h_rad)
                cos_sum += weights[i] * np.cos(h_rad)

        final_h = np.rad2deg(np.arctan2(sin_sum, cos_sum))
        if final_h < 0:
            final_h += 360

    # Convert back to Oklab
    h_rad = np.deg2rad(final_h)
    final_a = final_c * np.cos(h_rad)
    final_b = final_c * np.sin(h_rad)

    return np.array([final_l, final_a, final_b])


@numba.njit(parallel=True)
def transform_pixels(
    pixels_lab: np.ndarray,
    pixels_lch: np.ndarray,
    attractors_lab: np.ndarray,
    attractors_lch: np.ndarray,
    tolerances: np.ndarray,
    strengths: np.ndarray,
    flags: np.ndarray,
) -> np.ndarray:
    """
    Transform all pixels using Numba parallel processing.

    Args:
        pixels_lab: Image in Oklab space (H, W, 3)
        pixels_lch: Image in OKLCH space (H, W, 3)
        attractors_lab: Attractor colors in Oklab
        attractors_lch: Attractor colors in OKLCH
        tolerances: Tolerance values for each attractor
        strengths: Strength values for each attractor
        flags: Boolean array [luminance, saturation, hue]

    Returns:
        Transformed image in Oklab space

    """
    h, w = pixels_lab.shape[:2]
    result = np.empty_like(pixels_lab)

    for y in numba.prange(h):
        for x in range(w):
            pixel_lab = pixels_lab[y, x]
            pixel_lch = pixels_lch[y, x]

            # Calculate weights for all attractors
            weights = calculate_weights(pixel_lab, attractors_lab, tolerances, strengths)

            # Blend colors
            result[y, x] = blend_colors(pixel_lab, pixel_lch, attractors_lab, attractors_lch, weights, flags)

    return result


class ColorTransformer:
    """High-level color transformation interface.

    Manages the transformation pipeline from RGB input to RGB output,
    handling color space conversions, tiling for large images, and
    progress tracking. Used by the main CLI for applying transformations.

    Used in:
    - old/imgcolorshine/imgcolorshine/__init__.py
    - old/imgcolorshine/imgcolorshine_main.py
    - old/imgcolorshine/test_imgcolorshine.py
    - src/imgcolorshine/__init__.py
    - src/imgcolorshine/imgcolorshine.py
    """

    def __init__(self, engine: OKLCHEngine):
        """
        Initialize the color transformer.

        Args:
            engine: OKLCH color engine instance

        """
        self.engine = engine
        logger.debug("Initialized ColorTransformer")

    def transform_image(
        self,
        image: np.ndarray,
        attractors: list[Attractor],
        flags: dict[str, bool],
        progress_callback: Callable[[float], None] | None = None,
    ) -> np.ndarray:
        """
        Transform an entire image using color attractors.

        Args:
            image: Input image (H, W, 3) in sRGB [0, 1]
            attractors: List of color attractors
            flags: Channel flags {'luminance': bool, 'saturation': bool, 'hue': bool}
            progress_callback: Optional callback for progress updates

        Returns:
            Transformed image in sRGB [0, 1]

        Used in:
        - old/imgcolorshine/imgcolorshine_main.py
        - old/imgcolorshine/test_imgcolorshine.py
        - src/imgcolorshine/imgcolorshine.py
        """
        logger.info(f"Transforming {image.shape[0]}×{image.shape[1]} image with {len(attractors)} attractors")

        # Convert flags to numpy array
        flags_array = np.array(
            [
                flags.get("luminance", True),
                flags.get("saturation", True),
                flags.get("hue", True),
            ]
        )

        # Prepare attractor data for Numba
        attractors_lab = np.array([a.oklab_values for a in attractors])
        attractors_lch = np.array([a.oklch_values for a in attractors])
        tolerances = np.array([a.tolerance for a in attractors])
        strengths = np.array([a.strength for a in attractors])

        # Check if we should use tiling
        h, w = image.shape[:2]
        from imgcolorshine.image_io import ImageProcessor

        processor = ImageProcessor()

        if processor.should_use_tiling(w, h):
            # Process in tiles for large images
            def transform_tile(tile):
                return self._transform_tile(
                    tile,
                    attractors_lab,
                    attractors_lch,
                    tolerances,
                    strengths,
                    flags_array,
                )

            result = process_large_image(
                image,
                transform_tile,
                tile_size=processor.tile_size,
                progress_callback=progress_callback,
            )
        else:
            # Process entire image at once
            result = self._transform_tile(
                image,
                attractors_lab,
                attractors_lch,
                tolerances,
                strengths,
                flags_array,
            )

            if progress_callback:
                progress_callback(1.0)

        logger.info("Transformation complete")
        return result

    def _transform_tile(
        self,
        tile: np.ndarray,
        attractors_lab: np.ndarray,
        attractors_lch: np.ndarray,
        tolerances: np.ndarray,
        strengths: np.ndarray,
        flags: np.ndarray,
    ) -> np.ndarray:
        """Transform a single tile of the image."""
        # Convert to Oklab
        tile_lab = self.engine.batch_rgb_to_oklab(tile)

        # Also need OKLCH for channel-specific operations
        tile_lch = np.zeros_like(tile_lab)
        for y in range(tile_lab.shape[0]):
            for x in range(tile_lab.shape[1]):
                l, a, b = tile_lab[y, x]
                tile_lch[y, x] = self.engine.oklab_to_oklch(l, a, b)

        # Apply transformation
        transformed_lab = transform_pixels(
            tile_lab,
            tile_lch,
            attractors_lab,
            attractors_lch,
            tolerances,
            strengths,
            flags,
        )

        # Convert back to RGB
        result = self.engine.batch_oklab_to_rgb(transformed_lab)

        # Ensure values are in valid range
        return np.clip(result, 0, 1)
</file>

<file path="src/imgcolorshine/utils.py">
#!/usr/bin/env -S uv run -s
# /// script
# dependencies = ["numpy", "loguru"]
# ///
# this_file: src/imgcolorshine/utils.py

"""
Utility functions for memory management and image processing.

Provides helper functions for tiled processing of large images,
memory estimation, validation, and batch operations. Essential
for handling images that exceed available memory.

"""

from collections.abc import Callable

import numpy as np
from loguru import logger


def process_large_image(
    image: np.ndarray,
    transform_func: Callable[[np.ndarray], np.ndarray],
    tile_size: int = 1024,
    overlap: int = 32,
    progress_callback: Callable[[float], None] | None = None,
) -> np.ndarray:
    """
    Process a large image in tiles to manage memory usage.

    Args:
        image: Input image array
        transform_func: Function to apply to each tile
        tile_size: Size of each tile
        overlap: Overlap between tiles to avoid edge artifacts
        progress_callback: Optional callback for progress updates

    Returns:
        Processed image

    Used by transforms.py for processing images that exceed memory limits.

    Used in:
    - old/imgcolorshine/imgcolorshine/__init__.py
    - old/imgcolorshine/imgcolorshine/transforms.py
    - src/imgcolorshine/transforms.py
    """
    h, w = image.shape[:2]
    result = np.zeros_like(image)

    # Calculate number of tiles
    tiles_y = (h + tile_size - 1) // tile_size
    tiles_x = (w + tile_size - 1) // tile_size
    total_tiles = tiles_y * tiles_x
    processed_tiles = 0

    logger.info(f"Processing image in {tiles_x}×{tiles_y} tiles (size: {tile_size}×{tile_size})")

    for ty in range(tiles_y):
        for tx in range(tiles_x):
            # Calculate tile boundaries with overlap
            y_start = ty * tile_size
            y_end = min((ty + 1) * tile_size + overlap, h)
            x_start = tx * tile_size
            x_end = min((tx + 1) * tile_size + overlap, w)

            # Extract tile
            tile = image[y_start:y_end, x_start:x_end]

            # Process tile
            processed_tile = transform_func(tile)

            # Calculate the region to copy (without overlap)
            copy_y_start = 0 if ty == 0 else overlap // 2
            copy_y_end = processed_tile.shape[0] if ty == tiles_y - 1 else -overlap // 2
            copy_x_start = 0 if tx == 0 else overlap // 2
            copy_x_end = processed_tile.shape[1] if tx == tiles_x - 1 else -overlap // 2

            # Calculate destination coordinates
            dest_y_start = y_start if ty == 0 else y_start + overlap // 2
            dest_y_end = y_end if ty == tiles_y - 1 else y_end - overlap // 2
            dest_x_start = x_start if tx == 0 else x_start + overlap // 2
            dest_x_end = x_end if tx == tiles_x - 1 else x_end - overlap // 2

            # Copy processed tile to result
            result[dest_y_start:dest_y_end, dest_x_start:dest_x_end] = processed_tile[
                copy_y_start:copy_y_end, copy_x_start:copy_x_end
            ]

            # Update progress
            processed_tiles += 1
            if progress_callback:
                progress = processed_tiles / total_tiles
                progress_callback(progress)

            logger.debug(f"Processed tile ({tx}, {ty}) - {processed_tiles}/{total_tiles}")

    return result


def estimate_optimal_tile_size(image_shape: tuple, available_memory_mb: int = 2048, bytes_per_pixel: int = 12) -> int:
    """
    Estimate optimal tile size based on available memory.

    Args:
        image_shape: Shape of the image (H, W, C)
        available_memory_mb: Available memory in MB
        bytes_per_pixel: Estimated bytes per pixel for processing

    Returns:
        Optimal tile size

    """
    # Convert to bytes
    available_bytes = available_memory_mb * 1024 * 1024

    # Account for overhead (input, output, intermediate)
    overhead_factor = 3.0
    usable_bytes = available_bytes / overhead_factor

    # Calculate pixels that fit in memory
    pixels_in_memory = usable_bytes / bytes_per_pixel

    # Find square tile size
    tile_size = int(np.sqrt(pixels_in_memory))

    # Round to nearest power of 2 for efficiency
    tile_size = 2 ** int(np.log2(tile_size))

    # Clamp to reasonable range
    tile_size = max(256, min(tile_size, 4096))

    logger.debug(f"Optimal tile size: {tile_size}×{tile_size} (for {available_memory_mb}MB memory)")

    return tile_size


def create_progress_bar(total_steps: int, description: str = "Processing"):
    """
    Create a simple progress tracking context.

    This is a placeholder for integration with rich.progress or tqdm.

    """

    class SimpleProgress:
        """"""

        def __init__(self, total: int, desc: str):
            """"""
            self.total = total
            self.current = 0
            self.desc = desc

        def update(self, n: int = 1):
            """"""
            self.current += n
            percent = (self.current / self.total) * 100
            logger.info(f"{self.desc}: {percent:.1f}%")

        def __enter__(self):
            """"""
            return self

        def __exit__(self, *args):
            """"""

    return SimpleProgress(total_steps, description)


def validate_image(image: np.ndarray) -> None:
    """
    Validate image array format and values.

    Args:
        image: Image array to validate

    Raises:
        ValueError: If image is invalid

    Used in:
    - src/imgcolorshine/__init__.py
    """
    if image.ndim != 3:
        msg = f"Image must be 3D (H, W, C), got shape {image.shape}"
        raise ValueError(msg)

    if image.shape[2] != 3:
        msg = f"Image must have 3 channels (RGB), got {image.shape[2]}"
        raise ValueError(msg)

    if image.dtype not in (np.float32, np.float64):
        msg = f"Image must be float32 or float64, got {image.dtype}"
        raise ValueError(msg)

    if np.any(image < 0) or np.any(image > 1):
        msg = "Image values must be in range [0, 1]"
        raise ValueError(msg)


def clamp_to_gamut(colors: np.ndarray) -> np.ndarray:
    """
    Clamp colors to valid sRGB gamut.

    Args:
        colors: Array of colors in sRGB space

    Returns:
        Clamped colors

    """
    return np.clip(colors, 0, 1)


def batch_process_images(image_paths: list, output_dir: str, transform_func: Callable, **kwargs) -> None:
    """
    Process multiple images in batch.

    Args:
        image_paths: List of input image paths
        output_dir: Directory for output images
        transform_func: Transformation function
        **kwargs: Additional arguments for transform_func

    Used in:
    - src/imgcolorshine/__init__.py
    """
    from pathlib import Path

    from imgcolorshine.image_io import ImageProcessor

    output_dir = Path(output_dir)
    output_dir.mkdir(parents=True, exist_ok=True)

    processor = ImageProcessor()

    for i, image_path in enumerate(image_paths):
        logger.info(f"Processing image {i + 1}/{len(image_paths)}: {image_path}")

        # Load image
        image = processor.load_image(image_path)

        # Transform
        result = transform_func(image, **kwargs)

        # Save with same filename
        output_path = output_dir / Path(image_path).name
        processor.save_image(result, output_path)

        logger.info(f"Saved: {output_path}")
</file>

<file path=".cursorindexingignore">
# Don't index SpecStory auto-save files, but allow explicit context inclusion via @ references
.specstory/**
</file>

<file path=".gitignore">
*_autogen/
.DS_Store
__version__.py
__pycache__/
_Chutzpah*
_deps
_NCrunch_*
_pkginfo.txt
_Pvt_Extensions
_ReSharper*/
_TeamCity*
_UpgradeReport_Files/
!?*.[Cc]ache/
!.axoCover/settings.json
!.vscode/extensions.json
!.vscode/launch.json
!.vscode/settings.json
!.vscode/tasks.json
!**/[Pp]ackages/build/
!Directory.Build.rsp
.*crunch*.local.xml
.axoCover/*
.builds
.cr/personal
.fake/
.history/
.ionide/
.localhistory/
.mfractor/
.ntvs_analysis.dat
.paket/paket.exe
.sass-cache/
.vs/
.vscode
.vscode/*
.vshistory/
[Aa][Rr][Mm]/
[Aa][Rr][Mm]64/
[Bb]in/
[Bb]uild[Ll]og.*
[Dd]ebug/
[Dd]ebugPS/
[Dd]ebugPublic/
[Ee]xpress/
[Ll]og/
[Ll]ogs/
[Oo]bj/
[Rr]elease/
[Rr]eleasePS/
[Rr]eleases/
[Tt]est[Rr]esult*/
[Ww][Ii][Nn]32/
*_h.h
*_i.c
*_p.c
*_wpftmp.csproj
*- [Bb]ackup ([0-9]).rdl
*- [Bb]ackup ([0-9][0-9]).rdl
*- [Bb]ackup.rdl
*.[Cc]ache
*.[Pp]ublish.xml
*.[Rr]e[Ss]harper
*.a
*.app
*.appx
*.appxbundle
*.appxupload
*.aps
*.azurePubxml
*.bim_*.settings
*.bim.layout
*.binlog
*.btm.cs
*.btp.cs
*.build.csdef
*.cab
*.cachefile
*.code-workspace
*.coverage
*.coveragexml
*.d
*.dbmdl
*.dbproj.schemaview
*.dll
*.dotCover
*.DotSettings.user
*.dsp
*.dsw
*.dylib
*.e2e
*.exe
*.gch
*.GhostDoc.xml
*.gpState
*.ilk
*.iobj
*.ipdb
*.jfm
*.jmconfig
*.la
*.lai
*.ldf
*.lib
*.lo
*.log
*.mdf
*.meta
*.mm.*
*.mod
*.msi
*.msix
*.msm
*.msp
*.ncb
*.ndf
*.nuget.props
*.nuget.targets
*.nupkg
*.nvuser
*.o
*.obj
*.odx.cs
*.opendb
*.opensdf
*.opt
*.out
*.pch
*.pdb
*.pfx
*.pgc
*.pgd
*.pidb
*.plg
*.psess
*.publishproj
*.publishsettings
*.pubxml
*.pyc
*.rdl.data
*.rptproj.bak
*.rptproj.rsuser
*.rsp
*.rsuser
*.sap
*.sbr
*.scc
*.sdf
*.sln.docstates
*.sln.iml
*.slo
*.smod
*.snupkg
*.so
*.suo
*.svclog
*.tlb
*.tlh
*.tli
*.tlog
*.tmp
*.tmp_proj
*.tss
*.user
*.userosscache
*.userprefs
*.vbp
*.vbw
*.VC.db
*.VC.VC.opendb
*.VisualState.xml
*.vsp
*.vspscc
*.vspx
*.vssscc
*.xsd.cs
**/[Pp]ackages/*
**/*.DesktopClient/GeneratedArtifacts
**/*.DesktopClient/ModelManifest.xml
**/*.HTMLClient/GeneratedArtifacts
**/*.Server/GeneratedArtifacts
**/*.Server/ModelManifest.xml
*~
~$*
$tf/
AppPackages/
artifacts/
ASALocalRun/
AutoTest.Net/
Backup*/
BenchmarkDotNet.Artifacts/
bld/
BundleArtifacts/
ClientBin/
cmake_install.cmake
CMakeCache.txt
CMakeFiles
CMakeLists.txt.user
CMakeScripts
CMakeUserPresets.json
compile_commands.json
coverage*.info
coverage*.json
coverage*.xml
csx/
CTestTestfile.cmake
dlldata.c
DocProject/buildhelp/
DocProject/Help/*.hhc
DocProject/Help/*.hhk
DocProject/Help/*.hhp
DocProject/Help/*.HxC
DocProject/Help/*.HxT
DocProject/Help/html
DocProject/Help/Html2
ecf/
FakesAssemblies/
FodyWeavers.xsd
Generated_Code/
Generated\ Files/
healthchecksdb
install_manifest.txt
ipch/
Makefile
MigrationBackup/
mono_crash.*
nCrunchTemp_*
node_modules/
nunit-*.xml
OpenCover/
orleans.codegen.cs
Package.StoreAssociation.xml
paket-files/
project.fragment.lock.json
project.lock.json
publish/
PublishScripts/
rcf/
ScaffoldingReadMe.txt
ServiceFabricBackup/
StyleCopReport.xml
Testing
TestResult.xml
UpgradeLog*.htm
UpgradeLog*.XML
x64/
x86/
# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# Distribution / packaging
!dist/.gitkeep

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/
cover/
.ruff_cache/

# Environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# IDE
.idea/
.vscode/
*.swp
*.swo
*~

# OS
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Project specific
__version__.py
_private
VERSION.txt
</file>

<file path=".pre-commit-config.yaml">
repos:
  - repo: https://github.com/astral-sh/ruff-pre-commit
    rev: v0.3.4
    hooks:
      - id: ruff
        args: [--fix]
      - id: ruff-format
        args: [--respect-gitignore]
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.5.0
    hooks:
      - id: trailing-whitespace
      - id: check-yaml
      - id: check-toml
      - id: check-added-large-files
      - id: debug-statements
      - id: check-case-conflict
      - id: mixed-line-ending
        args: [--fix=lf]
</file>

<file path="CHANGELOG.md">
# Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [0.1.0] - 2025-01-14

### Added
- Initial release of imgcolorshine
- Core color transformation engine with OKLCH color space support
- High-performance image I/O with OpenCV and PIL fallback
- Numba-optimized pixel transformations with parallel processing
- CSS Color Module 4 compliant gamut mapping
- Multiple falloff functions (cosine, linear, quadratic, gaussian, cubic)
- Tiled processing for large images with memory management
- Click-based CLI interface with progress tracking
- Support for all CSS color formats (hex, rgb, hsl, oklch, named colors)
- Channel-specific transformations (luminance, saturation, hue)
- Multi-attractor blending with configurable tolerance and strength
- Comprehensive logging with loguru
- Rich console output with progress indicators

### Changed
- Migrated from Fire to Click for CLI implementation
- Restructured codebase to use modern Python packaging (src layout)
- Updated all modules to include proper type hints
- Enhanced documentation with detailed docstrings

### Technical Details
- Python 3.11+ required
- Dependencies: click, coloraide, opencv-python, numpy, numba, pillow, loguru, rich
- Modular architecture with separate modules for each concern
- JIT compilation for performance-critical code paths
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2025 Adam Twardoch

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="package.toml">
# Package configuration
[package]
include_cli = true        # Include CLI boilerplate
include_logging = true    # Include logging setup
use_pydantic = true      # Use Pydantic for data validation
use_rich = true          # Use Rich for terminal output

[features]
mkdocs = false           # Enable MkDocs documentation
vcs = true              # Initialize Git repository
github_actions = true   # Add GitHub Actions workflows
</file>

<file path="pyrightconfig.json">
{
  "include": [
    "**/*.py"
  ],
  "exclude": [
    ".",
    "**/node_modules",
    "**/__pycache__"
  ],
  "reportMissingImports": false,
  "reportMissingTypeStubs": false,
  "pythonVersion": "3.10"
}
</file>

<file path="TODO.md">
# TODO

## Completed

- [x] Create TODO.md and PLAN.md files for project organization
- [x] Review existing old implementation files to understand complete feature set
- [x] Port color_engine.py from old implementation to new structure
- [x] Port image_io.py, transforms.py, and other core modules
- [x] Implement CLI interface using Click
- [x] Update README.md with proper documentation
- [x] Create CHANGELOG.md to track changes

## Pending

- [ ] Add comprehensive tests for all modules
- [ ] Run Python formatting and linting tools
- [ ] Test the CLI with sample images
- [ ] Add GPU acceleration support (optional)

## Implementation Notes

- The old implementation in `old/imgcolorshine/` contains a complete working version
- Core modules to port: color_engine.py, image_io.py, transforms.py, gamut.py, falloff.py, utils.py
- Use modern Python packaging structure with src/ layout
- Maintain compatibility with the existing pyproject.toml configuration
</file>

<file path="src/imgcolorshine/imgcolorshine.py">
#!/usr/bin/env -S uv run -s
# /// script
# dependencies = ["loguru", "numpy"]
# ///
# this_file: src/imgcolorshine/imgcolorshine.py

"""
Core processing logic for imgcolorshine.

Contains the main image transformation pipeline.
"""

import sys
from pathlib import Path

from loguru import logger

from imgcolorshine import ColorTransformer, ImageProcessor, OKLCHEngine


def setup_logging(verbose: bool = False):
    """Configure loguru logging based on verbosity."""
    logger.remove()
    if verbose:
        logger.add(sys.stderr, level="DEBUG", format="{time:HH:mm:ss} | {level} | {message}")
    else:
        logger.add(sys.stderr, level="INFO", format="{message}")


def parse_attractor(attractor_str: str) -> tuple[str, float, float]:
    """Parse attractor string format: 'color;tolerance;strength'."""
    try:
        parts = attractor_str.split(";")
        if len(parts) != 3:
            msg = f"Invalid attractor format: {attractor_str}"
            raise ValueError(msg)

        color = parts[0].strip()
        tolerance = float(parts[1])
        strength = float(parts[2])

        if not 0 <= tolerance <= 100:
            msg = f"Tolerance must be 0-100, got {tolerance}"
            raise ValueError(msg)
        if not 0 <= strength <= 100:
            msg = f"Strength must be 0-100, got {strength}"
            raise ValueError(msg)

        return color, tolerance, strength
    except Exception as e:
        msg = f"Invalid attractor '{attractor_str}': {e}"
        raise ValueError(msg) from e


def generate_output_path(input_path: Path) -> Path:
    """Generate output filename if not provided."""
    stem = input_path.stem
    suffix = input_path.suffix
    return input_path.parent / f"{stem}_colorshine{suffix}"


def process_image(
    input_image: str,
    attractors: tuple[str, ...],
    output_image: str | None = None,
    luminance: bool = True,
    saturation: bool = True,
    hue: bool = True,
    verbose: bool = False,
    tile_size: int = 1024,
) -> None:
    """
    Process an image with color attractors.

    Main processing pipeline that handles logging setup, attractor parsing,
    image loading, transformation, and saving.

    Used in:
    - src/imgcolorshine/cli.py
    """
    setup_logging(verbose)

    # Convert to Path
    input_path = Path(input_image)

    # Validate inputs
    if not attractors:
        msg = "At least one attractor must be provided"
        raise ValueError(msg)

    if not any([luminance, saturation, hue]):
        msg = "At least one channel (luminance, saturation, hue) must be enabled"
        raise ValueError(msg)

    # Parse attractors
    logger.debug(f"Parsing {len(attractors)} attractors")
    parsed_attractors = []
    for attr_str in attractors:
        color, tolerance, strength = parse_attractor(attr_str)
        parsed_attractors.append((color, tolerance, strength))
        logger.debug(f"Attractor: color={color}, tolerance={tolerance}, strength={strength}")

    # Set output path
    if output_image is None:
        output_path = generate_output_path(input_path)
        logger.info(f"Output path auto-generated: {output_path}")
    else:
        output_path = Path(output_image)

    # Initialize components
    engine = OKLCHEngine()
    processor = ImageProcessor(tile_size=tile_size)
    transformer = ColorTransformer(engine)

    # Create attractor objects
    attractor_objects = []
    for color_str, tolerance, strength in parsed_attractors:
        attractor = engine.create_attractor(color_str, tolerance, strength)
        attractor_objects.append(attractor)

    # Load image
    logger.info(f"Loading image: {input_path}")
    image = processor.load_image(input_path)

    # Transform colors
    logger.info("Transforming colors...")
    flags = {"luminance": luminance, "saturation": saturation, "hue": hue}
    transformed = transformer.transform_image(image, attractor_objects, flags)

    # Save image
    logger.info(f"Saving image: {output_path}")
    processor.save_image(transformed, output_path)

    logger.info(f"Processing complete: {input_path} → {output_path}")
</file>

<file path="tests/test_package.py">
"""Test suite for imgcolorshine."""


def test_version():
    """Verify package exposes version."""
    import imgcolorshine

    assert imgcolorshine.__version__
</file>

<file path="cleanup.sh">
#!/usr/bin/env bash

rm -rf dist/imgcolorshine*.*
uv build

python -m uzpy run -e src
fd -e py -x autoflake -i {}
fd -e py -x pyupgrade --py311-plus {}
fd -e py -x ruff check --output-format=github --fix --unsafe-fixes {}
fd -e py -x ruff format --respect-gitignore --target-version py311 {}
repomix -i varia,.specstory,AGENT.md,CLAUDE.md,PLAN.md,SPEC.md,llms.txt,.cursorrules -o llms.txt .
python -m pytest
</file>

<file path="pyproject.toml">
# this_file: pyproject.toml
#==============================================================================
# IMGCOLORSHINE PACKAGE CONFIGURATION
# This pyproject.toml defines the package metadata, dependencies, build system,
# and development environment for the imgcolorshine package.
#==============================================================================

#------------------------------------------------------------------------------
# PROJECT METADATA
# Core package information used by PyPI and package managers.
#------------------------------------------------------------------------------
[project]
name = 'imgcolorshine' # Package name on PyPI
description = '' # Short description
readme = 'README.md' # Path to README file
requires-python = '>=3.10' # Minimum Python version
keywords = [
] # Keywords for PyPI search
dynamic = ["version"] # Fields set dynamically at build time

# PyPI classifiers for package categorization
classifiers = [
    'Development Status :: 4 - Beta', # Package maturity level
    'Programming Language :: Python',
    'Programming Language :: Python :: 3.10',
    'Programming Language :: Python :: 3.11',
    'Programming Language :: Python :: 3.12',
    'Programming Language :: Python :: Implementation :: CPython',
    'Programming Language :: Python :: Implementation :: PyPy',
    'Operating System :: OS Independent',
    'License :: OSI Approved :: MIT License',
    'Intended Audience :: Developers',
]

dependencies = [
    "fire>=0.6.0",
    "loguru>=0.7.0",
    "numpy>=1.24.0",
    "numba>=0.58.0",
    "coloraide>=3.2.0",
    "opencv-python>=4.8.0",
    "pillow>=10.0.0",
]

# Author information
[[project.authors]]
name = 'Adam Twardoch'
email = 'adam+github@twardoch.com'

# License information
[project.license]
text = 'MIT'

# Project URLs
[project.urls]
Documentation = 'https://github.com/twardoch/imgcolorshine#readme'
Issues = 'https://github.com/twardoch/imgcolorshine/issues'
Source = 'https://github.com/twardoch/imgcolorshine'

#------------------------------------------------------------------------------
# OPTIONAL DEPENDENCIES
# Additional dependencies for optional features, development, and testing.
#------------------------------------------------------------------------------
[project.optional-dependencies]

# Development tools
dev = [
    'pre-commit>=4.1.0', # Pre-commit hook manager - Keep pre-commit as is, update if newer pre-commit version is required
    'ruff>=0.9.7', # Linting and formatting - Keep ruff as is, update if newer ruff version is required
    'mypy>=1.15.0', # Type checking - Keep mypy as is, update if newer mypy version is required
    'absolufy-imports>=0.3.1', # Convert relative imports to absolute - Keep absolufy-imports as is, update if newer absolufy-imports version is required
    'pyupgrade>=3.19.1', # Upgrade Python syntax - Keep pyupgrade as is, update if newer pyupgrade version is required
    'isort>=6.0.1', # Sort imports - Keep isort as is, update if newer isort version is required
]

# Testing tools and frameworks
test = [
    'pytest>=8.3.4', # Testing framework - Keep pytest as is, update if newer pytest version is required
    'pytest-cov>=6.0.0', # Coverage plugin for pytest - Keep pytest-cov as is, update if newer pytest-cov version is required
    'pytest-xdist>=3.6.1', # Parallel test execution - Keep pytest-xdist as is, update if newer pytest-xdist version is required
    'pytest-benchmark[histogram]>=5.1.0', # Benchmarking plugin - Keep pytest-benchmark as is, update if newer pytest-benchmark version is required
    'pytest-asyncio>=0.25.3', # Async test support - Keep pytest-asyncio as is, update if newer pytest-asyncio version is required
    'coverage[toml]>=7.6.12',
]

docs = [
    "sphinx>=7.2.6",
    "sphinx-rtd-theme>=2.0.0",
    "sphinx-autodoc-typehints>=2.0.0",
    "myst-parser>=3.0.0", # Markdown support in Sphinx
]

# All optional dependencies combined
all = [
]

#------------------------------------------------------------------------------
# COMMAND-LINE SCRIPTS
# Entry points for command-line executables installed with the package.
#------------------------------------------------------------------------------
[project.scripts]
imgcolorshine = "imgcolorshine.cli:main"

#------------------------------------------------------------------------------
# BUILD SYSTEM CONFIGURATION
# Defines the tools required to build the package and the build backend.
#------------------------------------------------------------------------------
[build-system]
# Hatchling is a modern build backend for Python packaging
# hatch-vcs integrates with version control systems for versioning
requires = [
    'hatchling>=1.27.0', # Keep hatchling as is, update if newer hatchling version is required
    'hatch-vcs>=0.4.0', # Keep hatch-vcs as is, update if newer hatch-vcs version is required
]
build-backend = 'hatchling.build' # Specifies Hatchling as the build backend


#------------------------------------------------------------------------------
# HATCH BUILD CONFIGURATION
# Configures the build process, specifying which packages to include and
# how to handle versioning.
#------------------------------------------------------------------------------
[tool.hatch.build]
# Include package data files
include = [
    "src/imgcolorshine/py.typed", # For better type checking support
    "src/imgcolorshine/data/**/*", # Include data files if any

]
exclude = ["**/__pycache__", "**/.pytest_cache", "**/.mypy_cache"]

[tool.hatch.build.targets.wheel]
packages = ["src/imgcolorshine"]
reproducible = true


# Version control system hook configuration
# Automatically updates the version file from git tags
[tool.hatch.build.hooks.vcs]
version-file = "src/imgcolorshine/__version__.py"

# Version source configuration
[tool.hatch.version]
source = 'vcs' # Get version from git tags or other VCS info

# Metadata handling configuration
[tool.hatch.metadata]
allow-direct-references = true # Allow direct references in metadata (useful for local dependencies)


#------------------------------------------------------------------------------
# DEVELOPMENT ENVIRONMENTS

[tool.hatch.envs.default]
features = ['dev', 'test', 'all']
dependencies = [
]

# Commands available in the default environment
[tool.hatch.envs.default.scripts]
# Run tests with optional arguments
test = 'pytest {args:tests}'
# Run tests with coverage reporting
test-cov = "pytest --cov-report=term-missing --cov-config=pyproject.toml --cov=src/imgcolorshine --cov=tests {args:tests}"
# Run type checking
type-check = "mypy src/imgcolorshine tests"
# Run linting and formatting
lint = ["ruff check src/imgcolorshine tests", "ruff format --respect-gitignore src/imgcolorshine tests"]
# Format and fix style issues
fmt = ["ruff format --respect-gitignore src/imgcolorshine tests", "ruff check --fix src/imgcolorshine tests"]
fix = ["ruff check --fix --unsafe-fixes src/imgcolorshine tests", "ruff format --respect-gitignore src/imgcolorshine tests"]

# Matrix configuration to test across multiple Python versions

[[tool.hatch.envs.all.matrix]]
python = ["3.10", "3.11", "3.12"]

#------------------------------------------------------------------------------
# SPECIALIZED ENVIRONMENTS
# Additional environments for specific development tasks.
#------------------------------------------------------------------------------

# Dedicated environment for linting and code quality checks
[tool.hatch.envs.lint]
detached = true # Create a separate, isolated environment
features = ['dev'] # Use dev extras  dependencies 

# Linting environment commands
[tool.hatch.envs.lint.scripts]
# Type checking with automatic type installation
typing = "mypy --install-types --non-interactive {args:src/imgcolorshine tests}"
# Check style and format code
style = ["ruff check {args:.}", "ruff format --respect-gitignore {args:.}"]
# Format and fix style issues
fmt = ["ruff format --respect-gitignore {args:.}", "ruff check --fix {args:.}"]
fix = ["ruff check --fix --unsafe-fixes {args:.}", "ruff format --respect-gitignore {args:.}"]
# Run all ops
all = ["style", "typing", "fix"]

# Dedicated environment for testing
[tool.hatch.envs.test]
features = ['test'] # Use test extras as dependencies

# Testing environment commands
[tool.hatch.envs.test.scripts]
# Run tests in parallel
test = "python -m pytest -n auto {args:tests}"
# Run tests with coverage in parallel
test-cov = "python -m pytest -n auto --cov-report=term-missing --cov-config=pyproject.toml --cov=src/imgcolorshine --cov=tests {args:tests}"
# Run benchmarks
bench = "python -m pytest -v -p no:briefcase tests/test_benchmark.py --benchmark-only"
# Run benchmarks and save results
bench-save = "python -m pytest -v -p no:briefcase tests/test_benchmark.py --benchmark-only --benchmark-json=benchmark/results.json"

# Documentation environment
[tool.hatch.envs.docs]
features = ['docs']

# Documentation environment commands
[tool.hatch.envs.docs.scripts]
build = "sphinx-build -b html docs/source docs/build"

# GitHub Actions workflow configuration
[tool.hatch.envs.ci]
features = ['test']


[tool.hatch.envs.ci.scripts]
test = "pytest --cov=src/imgcolorshine --cov-report=xml"


#------------------------------------------------------------------------------
# CODE QUALITY TOOLS
# Configuration for linting, formatting, and code quality enforcement.
#------------------------------------------------------------------------------

#------------------------------------------------------------------------------
# COVERAGE CONFIGURATION
# Settings for test coverage measurement and reporting.
#------------------------------------------------------------------------------

# Path mapping for coverage in different environments
[tool.coverage.paths]
imgcolorshine = ["src/imgcolorshine", "*/imgcolorshine/src/imgcolorshine"]
tests = ["tests", "*/imgcolorshine/tests"]

# Coverage report configuration
[tool.coverage.report]
# Lines to exclude from coverage reporting
exclude_lines = [
    'no cov', # Custom marker to skip coverage
    'if __name__ == .__main__.:', # Script execution guard
    'if TYPE_CHECKING:', # Type checking imports and code
    'pass', # Empty pass statements
    'raise NotImplementedError', # Unimplemented method placeholders
    'raise ImportError', # Import error handling
    'except ImportError', # Import error handling
    'except KeyError', # Common error handling
    'except AttributeError', # Common error handling
    'except NotImplementedError', # Common error handling
]

[tool.coverage.run]
source_pkgs = ["imgcolorshine", "tests"]
branch = true # Measure branch coverage (if/else statements)
parallel = true # Support parallel test execution
omit = [
    "src/imgcolorshine/__about__.py",
]

#------------------------------------------------------------------------------
# MYPY CONFIGURATION
# Configuration for type checking with mypy.
#------------------------------------------------------------------------------

[tool.mypy]
python_version = "3.10"
warn_return_any = true
warn_unused_configs = true
disallow_untyped_defs = true
disallow_incomplete_defs = true
check_untyped_defs = true
disallow_untyped_decorators = true
no_implicit_optional = true
warn_redundant_casts = true
warn_unused_ignores = true
warn_no_return = true
warn_unreachable = true

[[tool.mypy.overrides]]
module = ["tests.*"]
disallow_untyped_defs = false
disallow_incomplete_defs = false

#------------------------------------------------------------------------------
# PYTEST CONFIGURATION
# Configuration for pytest, including markers, options, and benchmark settings.
#------------------------------------------------------------------------------

[tool.pytest.ini_options]
addopts = "-v --durations=10 -p no:briefcase"
asyncio_mode = "auto"
asyncio_default_fixture_loop_scope = "function"
console_output_style = "progress"
filterwarnings = ["ignore::DeprecationWarning", "ignore::UserWarning"]
log_cli = true
log_cli_level = "INFO"
markers = [
    "benchmark: marks tests as benchmarks (select with '-m benchmark')",
    "unit: mark a test as a unit test",
    "integration: mark a test as an integration test",
    "permutation: tests for permutation functionality", 
    "parameter: tests for parameter parsing",
    "prompt: tests for prompt parsing",
]
norecursedirs = [
    ".*",
    "build",
    "dist", 
    "venv",
    "__pycache__",
    "*.egg-info",
    "_private",
]
python_classes = ["Test*"]
python_files = ["test_*.py"]
python_functions = ["test_*"]
testpaths = ["tests"]

[tool.pytest-benchmark]
min_rounds = 100
min_time = 0.1
histogram = true
storage = "file"
save-data = true
compare = [
    "min",    # Minimum time
    "max",    # Maximum time
    "mean",   # Mean time
    "stddev", # Standard deviation
    "median", # Median time
    "iqr",    # Inter-quartile range
    "ops",    # Operations per second
    "rounds", # Number of rounds
]

#------------------------------------------------------------------------------
# RUFF CONFIGURATION
# Configuration for Ruff, including linter and formatter settings.
#------------------------------------------------------------------------------ 

# Ruff linter and formatter configuration
[tool.ruff]
target-version = "py310"
line-length = 120

# Linting rules configuration
[tool.ruff.lint]
# Rule sets to enable, organized by category
select = [
    # flake8 plugins and extensions
    'A', # flake8-builtins: checks for shadowed builtins
    'ARG', # flake8-unused-arguments: checks for unused function arguments
    'ASYNC', # flake8-async: checks for async/await issues
    'B', # flake8-bugbear: finds likely bugs and design problems
    'C', # flake8-comprehensions: helps write better list/dict comprehensions
    'DTZ', # flake8-datetimez: checks for datetime timezone issues
    'E', # pycodestyle errors: PEP 8 style guide errors
    'EM', # flake8-errmsg: checks for better error messages
    'F', # pyflakes: detects various errors
    'FBT', # flake8-boolean-trap: checks for boolean traps in function signatures
    'I', # isort: sorts imports
    'ICN', # flake8-import-conventions: checks for import conventions
    'ISC', # flake8-implicit-str-concat: checks for implicit string concatenation
    'LOG', # flake8-logging: checks for logging issues
    'N', # pep8-naming: checks naming conventions
    'PLC', # pylint convention: checks for convention issues
    'PLE', # pylint error: checks for errors
    'PLR', # pylint refactor: suggests refactors
    'PLW', # pylint warning: checks for suspicious code
    'PT', # flake8-pytest-style: checks pytest-specific style
    'PTH', # flake8-use-pathlib: checks for stdlib path usage vs pathlib
    'PYI', # flake8-pyi: checks stub files
    'RET', # flake8-return: checks return statement consistency
    'RSE', # flake8-raise: checks raise statements
    'RUF', # Ruff-specific rules
    'S', # flake8-bandit: checks for security issues
    'SIM', # flake8-simplify: checks for code simplification opportunities
    'T', # flake8-print: checks for print statements
    'TCH', # flake8-type-checking: helps with type-checking
    'TID', # flake8-tidy-imports: checks for tidy import statements
    'UP', # pyupgrade: checks for opportunities to use newer Python features
    'W', # pycodestyle warnings: PEP 8 style guide warnings
    'YTT', # flake8-2020: checks for misuse of sys.version or sys.version_info

]
# Rules to ignore (with reasons)
ignore = [
    'B027', # Empty method in abstract base class - sometimes needed for interfaces
    'C901', # Function is too complex - sometimes complexity is necessary
    'FBT003', # Boolean positional argument in function definition - sometimes unavoidable
    'PLR0911', # Too many return statements - sometimes needed for readability
    'PLR0912', # Too many branches - sometimes needed for complex logic
    'PLR0913', # Too many arguments - sometimes needed in APIs
    'PLR0915', # Too many statements - sometimes needed for comprehensive functions
    'PLR1714', # Consider merging multiple comparisons - sometimes less readable
    'PLW0603', # Using the global statement - sometimes necessary
    'PT013', # Pytest explicit test parameter - sometimes clearer
    'PTH123', # Path traversal - sometimes needed
    'PYI056', # Calling open() in pyi file - sometimes needed in type stubs
    'S105', # Possible hardcoded password - often false positives
    'S106', # Possible hardcoded password - often false positives
    'S107', # Possible hardcoded password - often false positives
    'S110', # try-except-pass - sometimes valid for suppressing exceptions
    'SIM102'
    # Nested if statements - sometimes more readable than combined conditions
]
# Rules that should not be automatically fixed
unfixable = [
    'F401', # Don't automatically remove unused imports - may be needed later

]
# Configure exclude to ignore specific directories
exclude = [".git", ".venv", "venv", "dist", "build", "old"]

# isort configuration within Ruff
[tool.ruff.lint.isort]
known-first-party = ['imgcolorshine'] # Treat as first-party imports for sorting

# flake8-tidy-imports configuration within Ruff
[tool.ruff.lint.flake8-tidy-imports]
ban-relative-imports = 'all' # Ban all relative imports for consistency

# Per-file rule exceptions
[tool.ruff.lint.per-file-ignores]
# Tests can use magic values, assertions, and relative imports
'tests/**/*' = [
    'PLR2004', # Allow magic values in tests for readability
    'S101', # Allow assertions in tests
    'TID252'
    # Allow relative imports in tests for convenience
]
</file>

<file path="README.md">
# imgcolorshine

Transform image colors using OKLCH color attractors - a physics-inspired tool that operates in perceptually uniform color space.

## Overview

`imgcolorshine` applies a gravitational-inspired color transformation where specified "attractor" colors pull the image's colors toward them. The tool works in the OKLCH color space, ensuring perceptually uniform and natural-looking results.

## Features

- **Perceptually Uniform**: Operations in OKLCH color space for intuitive results
- **Flexible Color Input**: Supports all CSS color formats (hex, rgb, hsl, oklch, named colors)
- **Selective Channel Control**: Transform lightness, saturation, and/or hue independently
- **Multiple Attractors**: Blend influences from multiple color targets
- **High Performance**: Optimized with NumPy and Numba for fast processing
- **Memory Efficient**: Automatic tiling for large images
- **Professional Quality**: CSS Color Module 4 compliant gamut mapping

## Installation

```bash
# Install from PyPI
pip install imgcolorshine

# Or install from source
git clone https://github.com/twardoch/imgcolorshine.git
cd imgcolorshine
pip install -e .
```

## Usage

### Basic Example

Transform an image to be more red:

```bash
imgcolorshine shine photo.jpg "red;50;75"
```

### Command Syntax

```bash
imgcolorshine shine INPUT_IMAGE ATTRACTOR1 [ATTRACTOR2 ...] [OPTIONS]
```

Each attractor has the format: `"color;tolerance;strength"`

- **color**: Any CSS color (e.g., "red", "#ff0000", "oklch(70% 0.2 120)")
- **tolerance**: 0-100 (radius of influence - how far the color reaches)
- **strength**: 0-100 (transformation intensity - how much colors are pulled)

### Options

- `--output_image PATH`: Output image file (auto-generated if not specified)
- `--luminance BOOL`: Enable/disable lightness transformation (default: True)
- `--saturation BOOL`: Enable/disable chroma transformation (default: True)
- `--hue BOOL`: Enable/disable hue transformation (default: True)
- `--verbose BOOL`: Enable verbose logging (default: False)
- `--tile_size INT`: Tile size for large images (default: 1024)

### Examples

**Warm sunset effect:**
```bash
imgcolorshine shine landscape.png \
  "oklch(80% 0.2 60);40;60" \
  "#ff6b35;30;80" \
  --output_image=sunset.png
```

**Shift only hues toward green:**
```bash
imgcolorshine shine portrait.jpg "green;60;90" \
  --luminance=False --saturation=False
```

**Multiple color influences:**
```bash
imgcolorshine shine photo.jpg \
  "oklch(70% 0.15 120);50;70" \
  "hsl(220 100% 50%);25;50" \
  "#ff00ff;30;40"
```


## How It Works

1. **Color Space**: All operations happen in OKLCH space for perceptual uniformity
2. **Attraction Model**: Each attractor color exerts influence based on:
   - **Distance**: How similar a pixel's color is to the attractor
   - **Tolerance**: Maximum distance at which influence occurs
   - **Strength**: Maximum transformation amount
3. **Falloff**: Smooth raised-cosine curve for natural transitions
4. **Blending**: Multiple attractors blend using normalized weighted averaging
5. **Gamut Mapping**: Out-of-bounds colors are mapped back to displayable range

## Understanding Parameters

### Tolerance (0-100)
- **Low values (0-20)**: Only very similar colors are affected
- **Medium values (30-60)**: Moderate range of colors transformed
- **High values (70-100)**: Wide range of colors influenced

### Strength (0-100)
- **Low values (0-30)**: Subtle color shifts
- **Medium values (40-70)**: Noticeable but natural transformations
- **High values (80-100)**: Strong color replacement

## Performance

- Processes a 1920×1080 image in ~2-5 seconds
- Automatic tiling for images larger than 2GB memory usage
- GPU acceleration available with CuPy (10-100x speedup)

## Technical Details

- **Color Engine**: ColorAide for accurate OKLCH operations
- **Image I/O**: OpenCV (4x faster than PIL for PNG)
- **Computation**: NumPy + Numba JIT compilation
- **Gamut Mapping**: CSS Color Module 4 algorithm
- **Falloff Function**: Raised cosine for smooth transitions

## Development

This project follows a structured approach focusing on code quality, documentation, and maintainable development practices.

## License

MIT License - see [LICENSE](LICENSE) file for details.

## Credits

- Created by Adam Twardoch
- Developed with Antropic software
</file>

</files>
